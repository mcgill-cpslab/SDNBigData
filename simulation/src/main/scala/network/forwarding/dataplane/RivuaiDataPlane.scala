package scalasem.network.forwarding.dataplane

import scala.collection.mutable.{HashMap, HashSet}

import scalasem.network.forwarding.controlplane.openflow.flowtable.{OFFlowTableBase, OFRivuaiFlowTableEntry}
import scalasem.network.forwarding.interface.OpenFlowPortManager
import scalasem.network.topology.{GlobalDeviceManager, HostType, Link, Node}
import scalasem.network.traffic._
import scalasem.simengine.SimulationEngine
import scalasem.util.XmlParser

class RivuaiDataPlane(val node: Node) extends ResourceAllocator {

  private val alpha: Double = XmlParser.getDouble("scalasim.rivuai.alpha", 0.5)
  private lazy val interfaceManager = node.interfacesManager.asInstanceOf[OpenFlowPortManager]

  // port -> (jobid -> using bandwidth)
  private val jobidToCurrentRating = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> using bandwidth)
  private val jobidToVirtualCapacity = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> allocated bandwidth to each job)
  private val jobidToAllocation = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> the flow number generated by the job in current switch)
  private val jobidToFlowNum = new HashMap[Short, HashMap[Int, Int]]

  /**
   * reallocate the flows' rate on the link, always called when a flow
   * is finished or off
   * @param link on the involved link
   */
  override def reallocate(link: Link) {
    // assuming the up layer are congestion free
    if (link.end_from.nodeType != HostType) return
    val inCallDataPlane = link.end_from.dataplane
    var remainingBandwidth = link.bandwidth
    //TODO: fix ChangingRateFlow bug
    if (!inCallDataPlane.linkFlowMap.contains(link)) return
    val sendingFlows = inCallDataPlane.linkFlowMap(link).filter(f => f.Rate != 0)
    var demandingflows = sendingFlows.clone()
    if (demandingflows.size != 0) {
      var avrRate = link.bandwidth / sendingFlows.size
      logDebug("avrRate on " + link + " is " + avrRate)
      demandingflows.map(f => {f.status = ChangingRateFlow; f.setTempRate(avrRate)})
      demandingflows = demandingflows.sorted(FlowRateOrdering)
      while (demandingflows.size != 0 && remainingBandwidth != 0) {
        //the flow with the minimum rate
        val currentflow = demandingflows.head
        val flowdest = GlobalDeviceManager.getNode(currentflow.dstIP)
        //try to acquire the max-min rate starting from the dest of this flow, the following function
        //recursively calls itself
        flowdest.dataplane.allocate(flowdest, currentflow, currentflow.getEgressLink)
        demandingflows.remove(0)
        if (demandingflows.size != 0) avrRate = remainingBandwidth / demandingflows.size
      }
    }
  }

  /**
   * perform max min allocation on the link
   * for now, if the flow's rate is reduced, it does not trigger the allocation
   * in the path of other flows
   * @param link the input link
   */
  override def allocate(link: Link) {
    // we have to check if the flow is in upper layer than the edge,
    // then we create congestion-free resources
    if (link.end_from.nodeType != HostType) return
    if (linkFlowMap(link).size == 0) return
    var demandingflows = linkFlowMap(link).clone()
    var remainingBandwidth = link.bandwidth
    if (demandingflows.size != 0) {
      var avrRate = link.bandwidth / linkFlowMap(link).size
      logDebug("avrRate on " + link + " is " + avrRate)
      demandingflows = demandingflows.sorted(FlowRateOrdering)
      while (demandingflows.size != 0 && remainingBandwidth != 0) {
        val currentflow = demandingflows.head
        //initialize for the new flow
        if (currentflow.getTempRate == Double.MaxValue)
          currentflow.setTempRate(link.bandwidth)
        //for paused flow, we keep the running Status but set its rate to 0
        //because if we remove it from the flow list, we may need to recalculate the
        //path for it
        val allowedRate = currentflow.ratelimit
        var demand = {
          if (currentflow.status != RunningFlow) math.min(currentflow.getTempRate, allowedRate)
          else math.min(currentflow.Rate, allowedRate)
        }
        logDebug("rate demand of flow " + currentflow + " is " + demand + ", status:" +
          currentflow.status)
        if (demand <= avrRate) {
          remainingBandwidth -= demand
        } else {
          if (currentflow.status == RunningFlow) {
            //TODO: if avrRate < currentflow.rate trigger the change on its path
            currentflow.changeRate(avrRate)
            logDebug("change flow " + currentflow + " rate to " + currentflow.Rate)
          } else {
            currentflow.setTempRate(avrRate) //set to avrRate
            logDebug("change flow " + currentflow + " temprate to " + currentflow.getTempRate)
          }
          remainingBandwidth -= avrRate
        }
        demandingflows.remove(0)
        if (demandingflows.size != 0) avrRate = remainingBandwidth / demandingflows.size
      }
    }
  }

  private def measureFlowRateOnEachPort() {
    // get the y_i on each port
    for (link <- interfaceManager.linkphysicalportsMap.keySet
         if Link.otherEnd(link, node).nodeType == HostType) {
      val host = Link.otherEnd(link, node)
      val inPortNum = interfaceManager.getPortByLink(link).getPortNumber
      if (host.dataplane.linkFlowMap.get(link) != None) {
        for (flow <- host.dataplane.linkFlowMap.get(link).get) {
          val currentRate = {
            val runDuration = SimulationEngine.currentTime - flow.startTime
            flow.updateTransferredData()
            if (runDuration == 0) 0
            else (flow.totalSize - flow.remainingAppData) / runDuration
          }
          logTrace("flow " + flow + " currentRate is " + currentRate)
          val jobBucket = jobidToCurrentRating.getOrElseUpdate(inPortNum,
            new HashMap[Int, Double]())
          jobBucket.getOrElseUpdate(flow.jobid, 0.0)
          jobBucket(flow.jobid) += currentRate
          if (flow.reqtype != 0) {
            //WFS flow
            jobidToFlowNum.getOrElseUpdate(inPortNum, new HashMap[Int, Int]).
              getOrElseUpdate(flow.jobid, 0)
            jobidToFlowNum(inPortNum)(flow.jobid) += 1
          }
          // save jobid -> vc for minimum guaranteed flows
          if (flow.reqtype == 0) {
            jobidToVirtualCapacity.getOrElseUpdate(inPortNum, new HashMap[Int, Double])
            jobidToVirtualCapacity(inPortNum) += flow.jobid -> flow.reqvalue
          }
        }
      }
    }
  }

  private def calculateCapacityForEachFlow() {
    // get capacity for weighted fair share flows on each port
    // port number -> allocation
    val totalCapacityToWFSFlow = new HashMap[Short, Double]
    //initialize
    for (link <- interfaceManager.linkphysicalportsMap.keySet
         if Link.otherEnd(link, node).nodeType == HostType) {
      totalCapacityToWFSFlow +=
        interfaceManager.getPortByLink(link).getPortNumber -> link.bandwidth
    }
    for (allocToMGEntry <- jobidToVirtualCapacity) {
      val link = interfaceManager.getLinkByPortNum(allocToMGEntry._1)
      val capacity  = link.bandwidth
      val host = Link.otherEnd(link, node)
      //FIFO for MG flows
      var totalMGRate = 0.0
      if (host.dataplane.linkFlowMap.get(link) != None) {
        for (flow <- host.dataplane.linkFlowMap(link) if flow.reqtype == 0) {
          if (totalMGRate + flow.reqvalue <= capacity) {
            totalMGRate += flow.reqvalue
          } else {
            flow.ratelimit = 0
          }
        }
      }
      totalCapacityToWFSFlow += allocToMGEntry._1 -> (capacity - totalMGRate)
    }

    // get C_i for every job
    // 1. get the sum of the priorities of jobs without minimum guarantee
    //  on each port
    val sumPerPort = new HashMap[Short, Double]
    for (link <- interfaceManager.linkphysicalportsMap.keySet
         if Link.otherEnd(link, node).nodeType == HostType) {
      val host = Link.otherEnd(link, node)
      val portNum = interfaceManager.getPortByLink(link).getPortNumber
      val selectedJob = new HashSet[Int]
      if (host.dataplane.linkFlowMap.get(link) != None) {
        for (flow <- host.dataplane.linkFlowMap(link) if flow.reqtype != 0) {
          sumPerPort.getOrElseUpdate(portNum, 0)
          if (!selectedJob.contains(flow.jobid))
            sumPerPort(portNum) += flow.reqvalue
        }
      }
    }
    // 2. get C_i for WFS flows
    for (link <- interfaceManager.linkphysicalportsMap.keySet
         if Link.otherEnd(link, node).nodeType == HostType) {
      val host = Link.otherEnd(link, node)
      val inPortNum = interfaceManager.getPortByLink(link).getPortNumber
      if (host.dataplane.linkFlowMap.get(link) != None) {
        for (flow <- host.dataplane.linkFlowMap(link) if flow.reqtype != 0) {
          if (inPortNum >= 0) {
            val jobBucket = jobidToVirtualCapacity.getOrElseUpdate(inPortNum,
              new HashMap[Int, Double]())
            jobBucket.getOrElseUpdate(flow.jobid, 0.0)
            jobBucket += flow.jobid ->
              ((flow.reqvalue / sumPerPort(inPortNum)) * totalCapacityToWFSFlow(inPortNum))
          }
        }
      }
    }
  }

  private def allocateToEachFlow() {
    // allocate R_i to each job
    for (allocPerPort <- jobidToCurrentRating; allocPerJob <- allocPerPort._2) {
      val jobid = allocPerJob._1
      val oldAlloc = allocPerJob._2
      val newJobCapacity = jobidToVirtualCapacity(allocPerPort._1)(jobid)
      val measuredSpeed = jobidToCurrentRating(allocPerPort._1)(jobid)
      val newAlloc = oldAlloc * (1 - alpha * ((measuredSpeed - newJobCapacity) / newJobCapacity))
      val jobAlloc = jobidToAllocation.getOrElseUpdate(allocPerPort._1, new HashMap[Int, Double])
      jobAlloc += jobid -> newAlloc
    }
    // allocate to each flow
    for (link <- interfaceManager.linkphysicalportsMap.keySet
         if Link.otherEnd(link, node).nodeType == HostType) {
      val host = Link.otherEnd(link, node)
      val inPort = interfaceManager.getPortByLink(link).getPortNumber
      if (host.dataplane.linkFlowMap.get(link) != None) {
        for (flow <- host.dataplane.linkFlowMap(link) if flow.reqtype != 0) {
          flow.ratelimit = jobidToAllocation(inPort)(flow.jobid) /
            jobidToFlowNum(inPort)(flow.jobid)
          logDebug("adjust flow " + flow + " allowed rate to " + flow.ratelimit +
            " at " + SimulationEngine.currentTime)
        }
      }
      reallocate(link)
    }
  }

  private[network] def regulateFlow() {
    measureFlowRateOnEachPort()
    calculateCapacityForEachFlow()
    allocateToEachFlow()
    reset()
  }

  def reset() {
    jobidToCurrentRating.clear()
    jobidToFlowNum.clear()
    jobidToVirtualCapacity.clear()
  }
}
