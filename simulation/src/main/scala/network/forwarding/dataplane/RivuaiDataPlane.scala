package scalasem.network.forwarding.dataplane

import scala.collection.mutable.HashMap

import scalasem.network.forwarding.controlplane.openflow.flowtable.{OFFlowTable, OFRivuaiFlowTableEntry}
import scalasem.network.forwarding.controlplane.openflow.RivuaiControlPlane
import scalasem.network.topology.{Link, Node}
import scalasem.network.traffic.GlobalFlowStore
import scalasem.util.XmlParser
import org.openflow.protocol.action.OFActionOutput
import scala.collection.mutable

class RivuaiDataPlane(node: Node) extends ResourceAllocator {

  private val alpha = XmlParser.getDouble("scalasim.rivuai.alpha", 0.5)
  private val controlPlane = node.controlplane.asInstanceOf[RivuaiControlPlane]
  private val interfaceManager = node.interfacesManager

  // port -> (jobid -> using bandwidth)
  private val jobidToCurrentRating = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> using bandwidth)
  private val jobidToVirtualCapacity = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> allocated bandwidth to each job)
  private val jobidToAllocation = new HashMap[Int, Double]
  // port -> (jobid -> the flow number generated by the job in current switch)
  private val jobidToFlowNum = new HashMap[Int, Int]

  override def reallocate(link: Link) {

  }

  override def allocate(link: Link) {

  }

  private[network] def regulateFlow() {
    // support only one flow table for now
    val flowTable = controlPlane.flowtables(0)

    //TODO: assigned to Minimum guarantee
    //port -> bandwidth allocated to minimum guaranteed flows
    val assignedToMinimumGuarantee = new HashMap[Short, Double]

    //get the y_i on each port
    for (entry <- flowTable.entries.values) {
      val rivuaiEntry = entry.asInstanceOf[OFRivuaiFlowTableEntry]
      val currentRate = GlobalFlowStore.getFlow(
        OFFlowTable.createMatchFieldFromOFMatch(rivuaiEntry.ofmatch)).rate
      val actionsOnFlow = rivuaiEntry.actions.filter(p => p.isInstanceOf[OFActionOutput])
      val flowIsAllowed = actionsOnFlow.size > 0
      if (flowIsAllowed) {
        val portNum = actionsOnFlow(0).asInstanceOf[OFActionOutput].getPort
        val jobBucket = jobidToCurrentRating.getOrElseUpdate(portNum, new HashMap[Int, Double]())
        jobBucket.getOrElseUpdate(rivuaiEntry.jobid, 0.0)
        jobBucket(rivuaiEntry.jobid) += currentRate
        if (rivuaiEntry.reqtype == 0) {
          val currentRate = assignedToMinimumGuarantee.getOrElseUpdate(portNum, 0.0)
          assignedToMinimumGuarantee(portNum) += currentRate
        }
      }
    }

    // get C_i
    // port number ->
    val sumOfCapacity = new HashMap[Short, Double]

    for (perPortAllocation <- jobidToCurrentRating) {
      val perPortRate
    }

    for (entry <- flowTable.entries.values) {

    }

    for (entry <- flowTable.entries.values) {

    }
    jobidToCurrentRating.clear()
  }
}
