package scalasem.network.forwarding.dataplane

import scala.collection.mutable.HashMap

import scalasem.network.forwarding.controlplane.openflow.flowtable.{OFFlowTable, OFRivuaiFlowTableEntry}
import scalasem.network.forwarding.controlplane.openflow.RivuaiControlPlane
import scalasem.network.forwarding.interface.OpenFlowPortManager
import scalasem.network.topology.{HostType, Link, Node}
import scalasem.network.traffic.GlobalFlowStore
import scalasem.util.XmlParser

class RivuaiDataPlane(node: Node) extends ResourceAllocator {

  private val alpha = XmlParser.getDouble("scalasim.rivuai.alpha", 0.5)
  private val controlPlane = node.controlplane.asInstanceOf[RivuaiControlPlane]
  private val interfaceManager = node.interfacesManager.asInstanceOf[OpenFlowPortManager]

  // port -> (jobid -> using bandwidth)
  private val jobidToCurrentRating = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> using bandwidth)
  private val jobidToVirtualCapacity = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> allocated bandwidth to each job)
  private val jobidToAllocation = new HashMap[Short, HashMap[Int, Double]]
  // port -> (jobid -> the flow number generated by the job in current switch)
  private val jobidToFlowNum = new HashMap[Short, HashMap[Int, Int]]

  override def reallocate(link: Link) {

  }

  override def allocate(link: Link) {

  }

  private def getInPortToHost(rivuaiEntry: OFRivuaiFlowTableEntry): Short =  {
    val inportNum = rivuaiEntry.inportNum
    val isIngressSwitch = inportNum >= 0 &&
      Link.otherEnd(interfaceManager.getLinkByPortNum(inportNum), node).nodeType == HostType
    if (isIngressSwitch) inportNum
    else -1
  }

  private[network] def regulateFlow() {
    // support only one flow table for now
    val flowTable = controlPlane.flowtables(0)

    // get the y_i on each port
    for (entry <- flowTable.entries.values) {
      val rivuaiEntry = entry.asInstanceOf[OFRivuaiFlowTableEntry]
      val flow = GlobalFlowStore.getFlow(
        OFFlowTable.createMatchFieldFromOFMatch(rivuaiEntry.ofmatch))
      val currentRate = flow.totalSize - flow.remainingAppData
      val inPortNum = getInPortToHost(rivuaiEntry)
      if (inPortNum >= 0) {
        val jobBucket = jobidToCurrentRating.getOrElseUpdate(inPortNum,
          new HashMap[Int, Double]())
        jobBucket.getOrElseUpdate(rivuaiEntry.jobid, 0.0)
        jobBucket(rivuaiEntry.jobid) += currentRate
        jobidToFlowNum.getOrElseUpdate(inPortNum, new HashMap[Int, Int]).
          getOrElseUpdate(rivuaiEntry.jobid, 0)
        jobidToFlowNum(inPortNum)(rivuaiEntry.jobid) += 1
        // save jobid -> vc for minimum guaranteed flows
        if (rivuaiEntry.reqtype == 0) {
          jobidToVirtualCapacity.getOrElseUpdate(inPortNum, new HashMap[Int, Double])
          jobidToVirtualCapacity(inPortNum) += rivuaiEntry.jobid -> rivuaiEntry.reqvalue
        }
      }
    }

    // get capacity for weighted fair share flows
    // port number -> allocation
    val totalCapacityToWFSFlow = new HashMap[Short, Double]
    for (allocToMGEntry <- jobidToVirtualCapacity) {
      val capacity  = interfaceManager.getLinkByPortNum(allocToMGEntry._1).bandwidth
      val allocToMGPerPort = jobidToVirtualCapacity(allocToMGEntry._1).values
      val allocSumToMGPerPort = allocToMGPerPort.reduceLeft(_ + _)
      totalCapacityToWFSFlow += allocToMGEntry._1 -> (capacity - allocSumToMGPerPort)
    }

    // get C_i for every job
    // 1. get the sum of the priorities of jobs without minimum guarantee
    //  on each port
    val sumPerPort = new HashMap[Short, Double]
    for (entry <- flowTable.entries.values
         if entry.asInstanceOf[OFRivuaiFlowTableEntry].reqtype != 0) {
      val rivuaiEntry = entry.asInstanceOf[OFRivuaiFlowTableEntry]
      sumPerPort.getOrElseUpdate(rivuaiEntry.inportNum, 0)
      sumPerPort(rivuaiEntry.inportNum) += rivuaiEntry.reqvalue
    }
    // 2. get C_i
    for (entry <- flowTable.entries.values
         if entry.asInstanceOf[OFRivuaiFlowTableEntry].reqtype != 0) {
      val rivuaiEntry = entry.asInstanceOf[OFRivuaiFlowTableEntry]
      val inPortNum = rivuaiEntry.inportNum
      if (inPortNum >= 0) {
        val jobBucket = jobidToVirtualCapacity.getOrElseUpdate(inPortNum,
          new HashMap[Int, Double]())
        jobBucket.getOrElseUpdate(rivuaiEntry.jobid, 0.0)
        jobBucket += rivuaiEntry.jobid ->
          ((rivuaiEntry.reqvalue / sumPerPort(inPortNum)) * totalCapacityToWFSFlow(inPortNum))
      }
    }

    // allocate R_i to each job
    for (allocPerPort <- jobidToAllocation; allocPerJob <- allocPerPort._2) {
      val jobid = allocPerJob._1
      val oldAlloc = allocPerJob._2
      val newJobCapacity = jobidToVirtualCapacity(allocPerPort._1)(jobid)
      val measuredSpeed = jobidToCurrentRating(allocPerPort._1)(jobid)
      val newAlloc = oldAlloc * (1 - alpha * ((measuredSpeed - newJobCapacity) / newJobCapacity))
      val jobAlloc = jobidToAllocation.getOrElseUpdate(allocPerPort._1, new HashMap[Int, Double])
      jobAlloc += jobid -> newAlloc
    }

    // allocate to each flow
    for (entry <- flowTable.entries.values) {
      val rivuaiEntry = entry.asInstanceOf[OFRivuaiFlowTableEntry]
      val outport = rivuaiEntry.outportNum
      rivuaiEntry.ratelimit = jobidToAllocation(outport)(rivuaiEntry.jobid) /
        jobidToFlowNum(outport)(rivuaiEntry.jobid)
    }
    reset()
  }

  def reset() {
    //jobidToAllocation.clear()
    jobidToCurrentRating.clear()
    jobidToFlowNum.clear()
    jobidToVirtualCapacity.clear()
  }
}
